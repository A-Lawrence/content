{% section "Graphs: first definitions" %}

A graph is abstract mathematical object, allowing to analyze wide variety of real-world processes. Saying "abstract", we mean graphs are abstraction of the same degree as, say, numbers. The numbers comes naturally when Matt calculates the amount of apples, the mass of sugar and temperature of air beyond the window. Studying numbers, you encounter new definitions: you are told, what is the square root of a number, what are divisors of a number. Moreover, you encounter different theorems about numbers: the square of sum formula, the fundamental theorem of arithmetic. Finally, when programming, you study algorithms about numbers: Euclidean algorithm, primality checks algorithms. All of these will happen to us when studying graphs.

<p>Start answering the question: why do we need graphs? what real-world objects they are helpful to study? Look at the Kyiv metro map:
{% img "1534/10_graphs/kyiv_underground_map.png" "80" %}
We see stations and tunnels here. Stations are connected with tunnels.

<p>Now look at a piece of Moscow (the screenshot is taken from <a href="http://maps.yandex.ru/">Yandex.Maps</a>).
{% img "1534/10_graphs/moscow_map.png" "80" %}
One can describe this composition of roads as the set of crossroads, some of which are connected with roads.


<p>Furthermore, look at the genealogic tree of slavic languages' group.

{% img "1534/10_graphs/slavic_languages.png" "100" %}

You can see the pack of languages, used previously or using currently by peoples of Europe. Linguists give common predecessor for several languages if they think these several languages are <i>kin</i> ones, i.e. in past were the same language (and, after that, accumulated big enough amount of differences, thus becoming different languages).

<p>Finally, let's have a look at a food chain from biology.
{% img "1534/10_graphs/food_web.png" "80" %}

<p>What's in common in all these pictures? The primary similarity is, there are <em>objects</em> and <em>connections between them</em> depicted. In graph theory all these pictures are called {% newword %}graphs{% endnewword %}. The graphs consist of {% newword %}vertices{% endnewword %} and {% newword %}edges{% endnewword %}. Thus, in Kyiv metro map stations are vertices and tunnels are edges. In the food chain graph species are vertices, and oriented edge is drawn from one species to another if the first species is the food for the second.

<p>So, a graph is a bunch of vertices and edges. Every edge connects two vertices. 

<p>The {% newword %}degree of a vertex{% endnewword %} is the number of edges, coming from (or going into) this vertex. For example, in metro map graphs most of vertices are of degree 2, but end stations are of degree 1. In the graph of slavic languages' group the vertex &laquo;West Slavic language&raquo; has the degree of 4.

{% img "1534/10_graphs/first_graph.png" "70" %}
<!-- Иллюстрации изготовлены в 
http://illuminations.nctm.org/ActivityDetail.aspx?ID=20 
-->

On this picture the vertex A has the degree of 3, the vertex B &mdash; the degree of 4. The vertex H is of zero degree and is called {% newword %}isolated vertex{% endnewword %}.

{% endsection %}

{% section "Types of graphs and routes in graphs" %}

For different objects and different connections between them, different types of graphs are used. For instance, a graph can be {% newword %}oriented{% endnewword %} and {% newword %}undirected{% endnewword %}. Oriented graphs are graphs, where for each edge (recall edge connects two vertices) is specified, which vertex is a source and which is a sink. Such edges are drawn by arrows. In examples provided, the food chain graph is oriented one, while the metro map graph is not.

<p>Now we want to discuss if the road graph is oriented one. Suppose we write a program which finds the shortest route between two points in city. There may be one-way traffic streets in the city, thus our program must take it into account. Consequently, each edge must come with possible directions of transport. If you can go in one direction, an arrowed edge is drawn; if you can ride in both directions, two-headed-arrowed edge is drawn.

<p>A {% newword %}path{% endnewword %} in a graph is any sequence of vertices, in which every two adjacent vertices are connected by edge. On the picture above A &rarr; C &rarr; B &rarr; G &mdash; is the path from the vertex A to the vertex G. There's shorter path from A to G: path A &rarr; B &rarr; G. The {% newword %}length of a path{% endnewword %} is the number of edges in it. Thus, the shortest path from A to G has the length of 2.

<p>A path is called {% newword %}cycle{% endnewword %}, if its first and last vertices are the same vertex. On the above picture the path A &rarr; C &rarr; B &rarr; D &rarr; A is cycle.

{% smartsnippet %}
If you look carefully on the definitions of path and cycle, you'll see the sequence A &rarr; D &rarr; B &rarr; D &rarr; B is also the path, and the sequence F &rarr; E &rarr; F is cycle. To exclude such pathological situations, the notions of simple path and simple cycle are generally introduced. A {% newword %}simple path{% endnewword %} is a path where no edges coincide. A {% newword %}simple cycle{% endnewword %} is a cycle, which is a single path.
{% endsmartsnippet %}

<p>(Be attentive here, now we introduce a complicated notion.) A {% newword %}connected component{% endnewword %} of a non-oriented graph is any set of its vertices, if the two following conditions are met:
    <ol>
        <li>any two vertices are connected, i.e. there exists at least one path between them;
        <li>this set cannot be extended; you cannot add another vertex without breaking the property 1.
    </ol>
Every undirected graph can be divided into its connected components. On the picture above, the graph has three connected components: {A, B, C, D, G}, {E, F} and {H}. Graphs who have one connected component are called {% newword %}connected{% endnewword %}. Graphs having more than one connected component are called {% newword %}disconnected{% endnewword %}. The graph depicted above is disconnected one.

<p>In oriented graph a path is any sequence of vertices, in which adjacent vertices are connected via edge, and this edge is directed from left to right (another commitments may apply). For example, on the picture below A &rarr; B &rarr; C &rarr; D is a path, and A &rarr; D &rarr; C &rarr; B &mdash; isn't a path (since there's no edges A &rarr; D and C &rarr; B in the graph).

{% img "1534/10_graphs/second_graph.png" "60" %}

<p>Some of the notions introduced by us for undirected graphs have analogues for the case of oriented graphs. For instance, along with the notion of &laquo;degree of a vertex&raquo;, in oriented graphs the notions of {% newword %}indegree{% endnewword %} (number of incoming edges) and {% newword %}outdegree{% endnewword %} (number of outgoing edges). On the picture above the vertex D has indegree of 1 and outdegree of 3.

<p>Finally, we'd like to stress that the following situations are possible in some graphs:

{% img "1534/10_graphs/third_graph.png" "80" %}

You see {% newword %}multiple edges{% endnewword %} connecting the vertices A and B, and the same for vertices C and D. Note that there are no multiple edges between vertices E and F, since oriented edges are muttiple only if these sources and sinks coincide (in another words, if the orientation is respected). The edges coming from the vertices G and H are called {% newword %}loops{% endnewword %}. Sometimes people say &laquo;graphs without loops and multiple edges&raquo; to stress what graphs do they take under consideration.

{% endsection %}




{% section "Trees" %}
In practice, some special types of graphs are often encountered. One of the frequent types are trees. A {% newword %}tree{% endnewword %} is a connected undirected graph without loops, without multiple edges and without cycles. Here's the typical example:

{% img "1534/10_graphs/fourth_graph.png" "70" %}

<p>Trees have some special properties. For example, in a tree a simple path exists between every two vertices. Indeed, if there were two vertices enjoying more than one simple path between them, it would lead to existence of simple cycle.

<p>Another surprising property of trees is the connection between the number of vertices and the number of edges. Let V denote the number of vertices and let E denote the number of edges. For tree depicted above V = 11, E = 10. We see that for this graph E = V &minus; 1.

<p>To understand whether it is always true, consider pendant vertices. A vertex of degree 1 is called {% newword %}pendant vertex{% endnewword %}. On the picture above, vertices A, C, F, G, H, J and K are pendant. Note that if there are at least two vertices in a tree, there always is at least one pendant vertex. Indeed, let us take an arbitrary vertex and walk in an arbitrary direction, never returning back. Since there are no cycles, with every new step we come to new and new vertices and eventually come to a vertex, from which there's nowhere to go. This vertex is pendant.

{% smartsnippet %}
Is it true that if a tree has at least two vertices, then it has at least two pendant vertices? Is it true that if a tree has at least three vertices, then it has at least three pendant vertices?
{% endsmartsnippet %}

{% theorem %}
For every tree E = V &minus; 1.
{% endtheorem %}

{% proof %}
As we figured out, if a tree has at least two vertices, then it has at least one pendant vertex. Choose this vertex and delete it together with the edge attached to it. Then the numbers of vertices and edges both decrease by one. Perform the same operation with obtained graph and so on and so on. Eventually we will come to the graph consisting of 1 vertex. For such graph V = 1, E = 0, i.e. E = V &minus; 1. Thus, for initial tree E = V &minus; 1 also holded.
{% endproof %}


{% endsection %}


{% section "How to store a graph in programs" %}
To represent a graph in the memory several ways are used. Enumerate (starting with 0) vertices of our graphs. Consider the following graph:

{% img "1534/10_graphs/fifth_graph.png" "40" %}

The first way to store it is the data structure &laquo;{% newword %}list of edges{% endnewword %}&raquo;. We construct the list of pairs of numbers. Every pair corresponds to an edge, every edge is represented by two numbers of its vertices.

{% noprogram %}
num_vertices = 6
edges_list = [[0, 1],  # this pair describes the edge between vertices 0 and 1
              [0, 2],
              [0, 4],
              [1, 2],
              [1, 3],
              [1, 4],
             ]
{% endnoprogram %}

Note that we have to store the total number of vertices in a variable &mdash; the reason is, <code>edges_list</code> has no information about isolated vertices.

<p>The second possible way to store this graph is data structure &laquo;{% newword %}adjacency matrix{% endnewword %}&raquo;. 
An adjacency matrix is a square table, where a<sub>ij</sub> is 1, if there exists edge from vertex <code>i</code> to the vertex <code>j</code>, and is 0 if there is no such edge.

{% noprogram %}
adjacency_matrix = [[0, 1, 1, 0, 1, 0],  
                    [1, 0, 1, 1, 1, 0],  # vertex 1 is connected to vertices 0,2,3,4
                    [1, 1, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0],
                    [1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                   ]
num_vertices = len(adjacency_matrix)
{% endnoprogram %}

Note that if a graph is undirected, its adjacency matrix is always symmetric (with respect to main diagonal; main diagonal is the diagonal connecting left-up and right-bottom elements). 

<p>Finally, third way to represent graphs: data structure &laquo;{% newword %}adjacency lists{% endnewword %}&raquo;. 
For each vertex, adjacency lists store the list of all its neighbors.

{% noprogram %}
adjacency_list = [[1, 2, 4],  # neighbors of 0 are listed here
                  [0, 2, 3, 4],
                  [0, 1],
                  [1],
                  [0, 1],
                  [],
                 ]
num_vertices = len(adjacency_list)                 
{% endnoprogram %}

To store an oriented graph, basically the same structures are applied, with reasonable corrections: 
<ul>
    <li>in the list of edges the edges are stored in the form of <code>[start, end]</code>;
    <li>in adjacency matrix an edge from <code>i</code> to <code>j</code> means <nobr><code>adjacency_matrix[i][j] == 1</code></nobr>, and if there is no edge backwards (no edge from <code>j</code> to <code>i</code>), <nobr><code>adjacency_matrix[j][i] == 0</code></nobr>;
    <li>in adjacency list for each vertice the numbers of vertices where outgoing edges come are stored.
</ul>

{% endsection %}


{% comment %}
{% section "Complexity of operations with different data structures" %}
complete graphs
{% endsection %}
{% endcomment %}
