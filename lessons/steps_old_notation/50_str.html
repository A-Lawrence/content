{% Step 1 of X %}
<h2>The string theory-1</h2>


<p>A string can be read from the standard input using the function <code>input()</code>
or defined in single or double quotes. 

{% program %}
a = 'No man is an island'
b = "Who is John Galt?"
your_string = input()

print(a)
print(b)
print(your_string)
{% inputdata %}

{% endinputdata %}
{% endprogram %}

{% instructions %}
1. Fill in the input field with something you like.
2. Run the program.
{% endinstructions %}

{% Step 2 of X %}
<h2>The string theory-2</h2>

You can repeat a string by multiplying it by an integer.


{% instructions %}
1. Type <code>print('>_<' * 5)</code>. 
2. Do you like the output? Personally, I don't.
3. Correct the string <code>'>_<'</code> such that smiles have spaces between them.
{% endinstructions %}

{% Step 3 of X %}
<h2>The string theory-3</h2>

{% program %}
print(len('abcdefghijklmnopqrstuvwxyz'))  # 26
{% endprogram %}

<p>A string in Python is a sequence of characters. The function <code>len(some_string)</code>
returns how many characters there are in a string:

{% instructions %}

{% endinstructions %}

{% Step 4 of X %}
<h2>The string theory-4</h2>

{% program %}
s = str(2 ** 100)
print(s)  # 1267650600228229401496703205376
print(len(s))  # 31
{% endprogram %}

<p>Every object in Python can be converted to string using the function <code>str(some_object)</code>.
So we can convert numbers to strings:

{% instructions %}

{% endinstructions %}




{% Step 5 of X %}
<h2>Slice Girls: a single character</h2>


<p>A slice gives from the given string one character or some fragment:
substring or subsequence.

<p>The simplest form of slice is a single character
slice: <code>S[i]</code> gives <code>i</code>th character of the string. Now, the hardest thing to get all this string business: <b>indexing starts at 0; the first element has index 0, the second has index 1, and so on</b>.
That is, if <code><nobr>S = 'Hello'</nobr></code>, 
<code><nobr>S[0] == 'H'</nobr></code>, <code><nobr>S[1] == 'e'</nobr></code>, <code><nobr>S[2] == 'l'</nobr></code>,
<code><nobr>S[3] == 'l'</nobr></code>, <code><nobr>S[4] == 'o'</nobr></code>.


{% Step 5 of X %}
<h2>No char type in Python</h2>

Note that in Python there is no separate type for characters of the string. <code>S[i]</code>
also has the type <code>str</code>, just as the source string. 

<p>Number <code>i</code> in <code>S[i]</code> is called <em>index</em>.

<p>If you specify a negative index, it is counted
from the end of your string, starting with the number <code>-1</code>. That is, <code><nobr>S[-1] == 'o'</nobr></code>,
<code><nobr>S[-2] == 'l'</nobr></code>, <code><nobr>S[-3] == 'l'</nobr></code>, <code><nobr>S[-4] == 'e'</nobr></code>,
<code><nobr>S[-5] == 'H'</nobr></code>. 

{% Step 6 of X %}
<h2>Table tennis</h2>

<p>Let's summarize it in the table:

<table border='1' cellspacing="0" cellpadding="3"> 
<tr> 
<th>String S</th> 
<td align="center">H</td> 
<td align="center">e</td> 
<td align="center">l</td> 
<td align="center">l</td> 
<td align="center">o</td> 
</tr> 
<tr> 
<th>Index</th> 
<td align="center">S[0]</td> 
<td align="center">S[1]</td> 
<td align="center">S[2]</td> 
<td align="center">S[3]</td> 
<td align="center">S[4]</td> 
</tr> 
<tr> 
<th>Index</th> 
<td align="center">S[-5]</td> 
<td align="center">S[-4]</td> 
<td align="center">S[-3]</td> 
<td align="center">S[-2]</td> 
<td align="center">S[-1]</td> 
</tr> 
</table>

{% Step 7 of X %}
<h2>Table tennis</h2>

{% program %}
s = "Don't print 1000-th symbol"
     
{% endprogram %}


<p>If the index in the slice <code>s[i]</code> is 
<ul>
<li>greater than or equal to <code>len(s)</code></li>
<li>or less than <code>-len(s)</code></li>
</ul>
the following error is caused <code>IndexError: string index out of range</code>.

So it's a bad idea to ask Python to <code>print(s[100])</code> for a short string like <code>s = "My morning portion of Snakify"</code>. For such string, there is no 101-th symbol (never forget any indexing in any programming languages starts at 0; the first symbol always has index 0).

{% instructions %}
1. Print the length of the given string.
2. Calculate the index of the last symbol.
3. Print the last symbol.
4. Try to print the symbol with index bigger than last by one, and enjoy the IndexError :3
{% endinstructions %}

{% hint %}
print(len(s))
last = len(s) - 1  
print(s[last]) 
print(s[last+1])   
{% endhint %}


{% Step 8 of X %}
<h2>What is substring?</h2>

{% program %}
s = 'Hello'
print(s[1:4])
print(s[-4:-1])
print(s[1:-1])
{% endprogram %}


<p>Slice with two parameters <code>s[a:b]</code> 
returns the substring of length <code>b - a</code>,
starting with the character at index <code>a</code> and
lasting until the character at index </code>b</code>, <b>not including it</b>.
For example, if <code>s == 'Hello'</code>, <code>s[1:4] == 'ell'</code>: for <code>s[1:4]</code> only indexes 1,2 and 3 are included.

You can get the same substring using <code>s[-4:-1]</code> (negative indexing starts from the end of a string).

You can mix positive and negative indexes in the same slice, for example, <code>s[1:-1]</code> is
exactly the same substring (the slice begins with the character with index 1 and 
ends with an index of -1, not including it).



{% Step 9 of X %}
<h2>Playing with parameters</h2>

{% program %}
s = 'Hello'
print(s[1:5])    # prints 'ello'
print(s[1:100])  # prints 'ello'
print(s[1:])     # prints 'ello'
print(s[:-1])    # prints 'Hell'
print(s[:])      # prints 'Hello'
{% endprogram %}

<p>Slices with two parameters never cause <code>IndexError</code>. For example, for <code>s == 'Hello'</code> 
the slice <code>s[1:5]</code> 
returns the string <code>'ello'</code>, and the result is the same as
if the second index was very large, like
<code>s[1:100]</code>.

<p>If you omit the second parameter (but preserve the colon),
then the slice goes to the end of string. For example, to remove
the first character from the string (its index is 0)
take the slice <code>s[1:]</code>. Similarly
if you omit the first parameter, then Python takes the slice from the beginning of the string.
That is, to remove the last character from the string, you can use slice
<code>s[:-1]</code>. The slice <code>s[:]</code> is equal to the string
<code>s</code> itself.


{% instructions %}

{% endinstructions %}

{% Step 10 of X %}
<h2>Immutability of strings</h2>

{% program %}
s = 'Hello'
t = s  # s and t point to the same string
t = s[2:4]  # now t points to the new string 'll'
print(s)  # prints 'Hello' as s is not changed
print(t)  # prints 'll'
{% endprogram %}


<p>
Any slice of a string creates a new string and never modifies the original one. The reason is, in Python strings are immutable, i.e they cannot be changed as objects.
You can only assign the variable to a new string, but the old one stays in memory.

<p>(In fact in Python there is no variables. There are only names that are pointing to objects.
You can first point with a name to an object, and then point to the same object with another name. Different names
can point to the same object.)</p>


{% Step 11 of X %}
<h2>Slices: specifying the step</h2>

{% program %}
s = 'abcdefg'
print(s[1])
print(s[-1])
print(s[1:3])
print(s[1:-1])
print(s[:3])
print(s[2:])
print(s[:-1])
print(s[::2])
print(s[1::2])
print(s[::-1])
{% endprogram %}

<p>If you specify a slice with three parameters <code>S[a:b:d]</code>,
the third parameter specifies the step, same as for function
<code>range()</code>. In this case only the characters with the following index are taken:
<code>a</code> <nobr><code>a + d</code></nobr>, <nobr><code>a + 2 * d</code></nobr> and so on, until and not 
including the character with index <code>b</code>.
If the third parameter equals to 2, the slice takes
every second character, and if the step of the slice equals to
<code>-1</code>, the characters go in reverse order. 
For example, you can reverse a string like this: <code>S[::-1]</code>.



{% instructions %}
Run the code to see what does each <code>print()</code> function output in this case.
{% endinstructions %}


{% Step 12 of X %}
<h2>Slices: specifying the step</h2>

Note how the third parameter of the slice is similar to the third parameter of the function <code>range()</code>:

{% program %}
s = 'abcdefghijklm'

print(s[0:10:2])

for i in range(0, 10, 2):
    print(i, s[i])
{% endprogram %}

{% allfine %}
These two two-line pieces of code are essentially the same.
{% endallfine %}

{% Step 13 of X %}
<h2>find() and rfind() methods</h2>

<p>A method is a function that is bound to the object. When the method is called,
the method is applied to the object and does some computations related to it.
Methods are invoked as <code>object_name.method_name(arguments)</code>.
For example, in <code>s.find(&quot;e&quot;)</code>&nbsp; the string method <code>find()</code> is applied to
the string <code>s</code> with one argument <code>&quot;e&quot;</code>.

{% instructions %}

{% endinstructions %}

{% Step 14 of X %}
<h2>find() method</h2>

{% program %}
s = 'Hello'
print(s.find('e'))
# 1
print(s.find('ll'))
# 2
print(s.find('L'))
# -1
{% endprogram %}

<p>Method <code>find()</code> searchs a substring, passed as an argument,
inside the string on which it's called.
The function returns the index of the first occurrence of the substring.
If the substring is not found, the method returns <code>-1</code>. 



{% instructions %}

{% endinstructions %}

{% Step 15 of X %}
<h2>rfind() method</h2>

<p>Similarly, the method <code>rfind()</code> returns the index of the last occurrence
of the substring.

{% program %}
s = 'abracadabra'
print(s.find('b'))
# 1
print(s.rfind('b'))
# 8
{% endprogram %}

{% instructions %}

{% endinstructions %}


{% Step 16 of X %}
<h2>rfind() method</h2>

<p>If you call <code>find()</code> with three arguments
<code>s.find(substring, left, right)</code>, the search is performed
inside the slice <code>s[left:right]</code>. If you specify only two arguments, like
<code>s.find(substring, left)</code>, the search is performed
in the slice <code>s[left:]</code>, that is, starting with the character at index
<code>left</code> to the end of the string. Method <code>s.find(substring, left, right)</code>
returns the absolute index, relatively to the whole string <code>s</code>, and not to the slice.

{% program %}
s = 'my name is bond, james bond, okay?'
print(s.find('bond'))
# 11
print(s.find('bond', 12))
# 23
{% endprogram %}

{% instructions %}

{% endinstructions %}

{% Step 17 of X %}
<h2>replace() method</h2>

{% program %}
print('a bar is a bar, essentially'.replace('bar', 'pub'))
{% endprogram %}

<p>Method <code>replace()</code> replaces all occurrences of a given substring with another one. Syntax
<code>s.replace(old, new)</code>&nbsp; takes the string <code>s</code> and replaces
all occurrences of substring <code>old</code> with the substring <code>new</code>. 

{% instructions %}
Run the code to see what happens.
{% endinstructions %}

{% Step 18 of X %}
<h2>replace() method: calling with three arguments</h2>

{% program %}
print('a bar is a bar, essentially'.replace('bar', 'pub', 1))
# 'a pub is a bar, essentially'
{% endprogram %}


<p>You can pass the third argument <code>count</code> using <code>replace()</code> method, like this: <code>s.replace(old, new, count)</code>. If the third argument is passed, only first <code>count</code> occurrences are replaced.


{% instructions %}

{% endinstructions %}

{% Step 19 of X %}
<h2>count() method</h2>

{% program %}
print('Abracadabra'.count('a'))
# this will print '4'

print(('aaaaaaaaaa').count('aa'))
# and this will print '5'
{% endprogram %}

<p>This method counts the number of occurrences of one string within another string. The simplest
form is this one: <code>s.count(substring)</code>. Only non-overlapping occurrences are taken into account.



{% Step 20 of X %}
<h2>count() method: calling with three arguments</h2>

{% program %}
print('A sailor went to sea to see what he could see, but all he could have see, was sea, sea, sea'.count('se', 25, -3))

# The function count() will calculate the slice [25:-3]. 
# The slice [25:-3] of
# 'A sailor went to sea to see what he could see, but all he could have see, was sea, sea, sea'
# is equal to
# 'ee what he could see, but all he could have see, was sea, sea, '
# Then the function count() is going to find occurences of 'se' in the resulting string. There are only four such occurences,
# thus it will print '4'.

{% endprogram %}

<p>If you specify three parameters <code><nobr>s.count(substring, left, right)</nobr></code>,
the count is performed within the slice <code>s[left:right]</code>.



<!-- ord, chr -->