{% section "Quickly on decorators" %}
<p>It's gonna be a long section; putting the long story short &mdash; here's an example of how decorators work:

{% program %}
def makebold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped
 
def makeitalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped
 
@makebold
@makeitalic
def hello():
    return "hello habr"
 
print hello() ## prints <b><i>hello habr</i></b>
{% endprogram %}

If you feel more detailed explanation is needed :), you've come to the right place.

{% endsection %}

{% section "Functions are objects in Python" %}

<p>To explain how decorators work we should firstly mention that in Python functions are also objects.
But what does this actually mean?

{% program %}
def shout(word="yes"):
    return word.capitalize()+"!"
 
print shout()
# prints: 'Yes!'
 
# Since function is also an object, you can associate it with a variable,
# as any other object
scream = shout
 
# Please note that we do not use brackets as we do not call the "shout" function. Instead,
# we associate it with "scream" variable. Now we can call
# call "shout" via "scream":

print scream()
# prints: 'Yes!'

# Futhermore this means we can now delete "shout", and it would be still available via "scream".
 
del shout
try:
    print shout()
except NameError, e:
    print e
    #prints: "name 'shout' is not defined"
 
print scream()
# prints: 'Yes!'
{% endprogram %}

<p>Remember this. We will need it soon, but before note that a function in Python can be defined ... inside another function!

{% program %}
def talk():
    # Inside the definition of function "talk" we can define another one...
    def whisper(word="yes"):
        return word.lower()+"...";
 
    # ... and use it immediately!
    print whisper()

# Now, EVERY TIME we call "talk", within it "whisper" function is defined and called.
talk()
# prints: "yes..."
 
# But outside the "talk" function there is NO "whisper" function:
try:
    print whisper()
except NameError, e:
    print e
    #print: "name 'whisper' is not defined"
{% endprogram %}


{% endsection %}

{% section "Links to functions" %}

Now we know that functions are objects and so they can be:

<ul>
<li>associated with a variable;</li>
<li>defined one inside another.</li>
</ul>

<p>This means a function can return another function!
Let's have a look:

{% program %}
def getTalk(type="shout"):
 
    # Defining function right here
    def shout(word="yes"):
        return word.capitalize()+"!"
 
    def whisper(word="yes") :
        return word.lower()+"...";
 
    # Returning necessary
    if type == "shout":
        # Note we do not use "()", as we don't need to call a function;
        # we need to return an object of the function
        return shout
    else:
        return whisper
 
# What do we do now with this?
# Let's take a function and associate it with a variable
talk = getTalk()

# As we can see now, "talk" is now an object of "function":
print talk
# prints: <function shout at 0xb7ea817c>
 
# Which can be called just as "regular" (i.e. regulary defined) function:
print talk()
 
# If we need we can call it directly from returned value:
print getTalk("whisper")()
# prints: yes...
{% endprogram %}

Well, if we can return function then we can pass it to another function as an argument:

{% program %}
def doSomethingBefore(func):
    print "I do something before I call the function you passed to me"
    print func()
 
doSomethingBefore(scream)
# prints:
# I do something before I call the function you passed to me
# Yes!
{% endprogram %}

Nice, now we understand how do decorators actually work.
As you could've already guessed, decorators are some kind of wrappings,  <b> that allows us to do something before and after  our decorated function work without changing it</b>.

{% endsection %}

{% section "Creating our own decorator manually" %}

{% program %}
# Decorator is a function which needs another function as an argument
def my_shiny_new_decorator(a_function_to_decorate):
    # Inside itself the decorator defines its wrap-function.
    # It will be (guess what?..) wrapped around a decorated one,
    # being able to do any code before and after it.

    def the_wrapper_around_the_original_function():
        # Here will be the code we want to launch before calling 
        # the original function
        print "I'm the code working before call"
 
        # Calling the decorated function itself
        a_function_to_decorate()

        # And here will be the code we want to launch after calling
        # the original function
        print "I'm the code working after call"

    # Right now the function  "a_function_to_decorate" HAVE NOT BEEN CALLED YET

    # Now we return wrap-function which contains
    # our decorated function and the code which is to be done before and after.
    # Just as simple as that!
    return the_wrapper_around_the_original_function

# Consider now we have a standalone function we're not going to change at all.
def a_stand_alone_function():
    print "I'm just a simple lonely function, won't you dare touching me!.."
 
a_stand_alone_function()
# prints: I'm just a simple lonely function, won't you dare touching me!....
 
# However to change its behavior we can decorate it, i.e.
# to pass any code we need to a decorator which will 
# wrap our function and return a new prepared one:
 
a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function_decorated()
# prints:
# I'm the code working before call
# I'm just a simple lonely function, won't you dare touching me!..
# I'm the code working after call
{% endprogram %}

<p>Now we probably want every time we call  <code>a_stand_alone_function</code>, instead  <code>a_stand_alone_function_decorated</code> is called. Nothing complicated, let's just rewrite  <code>a_stand_alone_function</code> with a function which  <code>my_shiny_new_decorator</code> returned:

{% program %}
a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function()
# prints:
# I'm the code working before call
# I'm just a simple lonely function, won't you dare touching me!..
# I'm the code working after call
{% endprogram %}

You probably already guessed that this is exactly what decorators do. :)

{% endsection %}

{% section "Destroying the aura of mystery around decorators" %}

<p>The previous example could be written another way by using the decorators syntax:

{% program %}
@my_shiny_new_decorator
def another_stand_alone_function():
    print "Leave me alone"
 
another_stand_alone_function()
# prints:
# I'm the code working before call
# Leave me alone
# I'm the code working after call
{% endprogram %}

<p>Yes it's THAT simple! @decorator is just a <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> for this kind of constructions:

{% program %}
another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
{% endprogram %}

Decorators are pythonic implementation of a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.  Python also includes  <a href="https://en.wikipedia.org/wiki/Software_design_pattern#Creational_patterns">creational patterns</a>, such as ones mentioned in this article, as well as <a href="https://en.wikipedia.org/wiki/Iterator_pattern">iterator patterns</a>, familiar to any pythonist.

<p>Of course, you can nest decorators inside each other like this:

{% program %}
def bread(func):
    def wrapper():
        print "</------\>"
        func()
        print "<\______/>"
    return wrapper
 
def ingredients(func):
    def wrapper():
        print "#tomatoes#"
        func()
        print "~salad~"
    return wrapper
 
def sandwich(food="--ham--"):
    print food
 
sandwich()
#prints: --ham--
sandwich = bread(ingredients(sandwich))
sandwich()
#prints:
# </------\>
# #tomatoes#
# --ham--
# ~salad~
# <\______/>
{% endprogram %}

And using a decorator syntax:

{% program %}
@bread
@ingredients
def sandwich(food="--ham--"):
    print food
 
sandwich()
#prints:
# </------\>
# #tomatoes#
# --ham--
# ~salad~
# <\______/>
{% endprogram %}

You should remember that the order of decoration <i>is</i> important:

{% program %}
@ingredients
@bread
def sandwich(food="--ham--"):
    print food
 
sandwich()
#prints:
# #tomatoes#
# </------\>
# --ham--
# <\______/>
# ~salad~
{% endprogram %}

<p>Actually, this is the moment when you can happily walk away, understanding you now know all about decorators.

<p>But for those ready fo a little brainstrom now we will  tell everything  about the advanced use of decorators. There will be discussed issues such as the transfer of the arguments of the decorated function, decoration of methods, decorators with parameters, etc.

<p>So, we have already became familiar with the decorators, the principles of their work and even wrote  our own decorator.
However, all decorators that we previously considered didn't have one very important functional, namely passing arguments to a decorated function.
Well, let's fix this!

{% endsection %}

{% section "Passing arguments to the decorated function" %}

<p>No black magic, all  we need is  in fact to pass the arguments on!

{% program %}
def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2): # arguments come from here
        print "Look what i received:", arg1, arg2
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments
 
# Now, when we call the function returned by a decorator,
# we call her "wrapping", pass the arguments to it and in then it passes them
# to the decorated function.
 
@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print "My name is", first_name, last_name
 
print_full_name("Peter", "Venkman")
# prints:
# Look what i received: Peter Venkman
# My name is Peter Venkman
# *
{% endprogram %}

{% endsection %}

{% section "Decorations of methods" %}

<p>The functions and methods in Python are pretty much similar, except that the methods always expect the first argument to be  a reference to the object itself (<code>self</code>). This means we can create decorators for methods as well as for functions, just do not forget about <code>self</code>.

{% program %}
def method_friendly_decorator(method_to_decorate):
    def wrapper(self, lie):
        lie = lie - 3 # friendly indeed, let's lower the age again :-)
        return method_to_decorate(self, lie)
    return wrapper
 
 
class Lucy(object):
 
    def __init__(self):
        self.age = 32
 
    @method_friendly_decorator
    def sayYourAge(self, lie):
        print "I'm %s, what did you expect?" % (self.age + lie)
 
l = Lucy()
l.sayYourAge(-3)
# prints: I'm 26, what did you expect?
{% endprogram %}

<p>Of course, if we create the most common decorator, and we want it to be appliable to any function or method, we should use the fact that <code>*args</code> unpacks the list of  <code>args</code>, and <code>**kwargs</code> unpacks dictionary <code>kwargs</code>:

{% program %}
def a_decorator_passing_arbitrary_arguments(function_to_decorate):
    # This "wrapping" accepts any arguments
    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):
        print "Have I received anything?:"
        print args
        print kwargs
        # We now unpack *args and **kwargs
        # If you are not too familiar with the unpacking, you can read the following article:
        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/
        function_to_decorate(*args, **kwargs)
    return a_wrapper_accepting_arbitrary_arguments
 
@a_decorator_passing_arbitrary_arguments
def function_with_no_argument():
    print "Python is cool, no argument here."
 
function_with_no_argument()
# prints:
# Have I received anything?:
# ()
# {}
# Python is cool, no argument here.

@a_decorator_passing_arbitrary_arguments
def function_with_arguments(a, b, c):
    print a, b, c
 
function_with_arguments(1,2,3)
# prints:
# Have I recieved anything?:
# (1, 2, 3)
# {}
# 1 2 3
 
@a_decorator_passing_arbitrary_arguments
def function_with_named_arguments(a, b, c, platypus="Why not?"):
    print "Does %s, %s and %s love platypus? %s" %\
    (a, b, c, platypus)
 
function_with_named_arguments("Bill", "Linus", "Steve", platypus="Definitely!")
# prints:
# Have I recieved anything?:
# ('Bill', 'Linus', 'Steve')
# {'platypus': 'Definitely!'}
# Does Bill, Linus, and Steve love platypus? Definitely!

class Mary(object):
 
    def __init__(self):
        self.age = 31
 
    @a_decorator_passing_arbitrary_arguments
    def sayYourAge(self, lie=-3): # We can now specify the default value
        print "I'm %s, what did you expect?" % (self.age + lie)
 
m = Mary()
m.sayYourAge()
# prints:
# Have I recieved anything?:
# (<__main__ .Mary object at 0xb7d303ac>,)
# {}
# I'm 28, what did you expect?
{% endprogram %}


{% endsection %}

{% section "Calling a decorator with arguments" %}

<p>Fine, this one is finished. Now how about  trying to call decorators with different arguments?

<p>It's not as easy as it seems, because a decorator must take the function as an argument, and we can not simply pass to it anything else.
So, before we show you the solution, let's once again have a look at  what we already know:

{% program %}
# Decorators are just functions
def my_decorator(func):
    print "I'm a simple function"
    def wrapper():
        print "I'm a function returned by the decorator"
        func()
    return wrapper
 
# So we can call her without using  "@"-syntax:
 
def lazy_function():
    print "zzzzzzzz"
 
decorated_function = my_decorator(lazy_function)
# prints: I'm a simple function
 
# This code prints the "I'm a simple function", because it's exactly what we have done:
# we called the function. Nothing supernatural.

@my_decorator
def lazy_function():
    print "zzzzzzzz"
 
# prints: I'm a simple function
{% endprogram %}

<p>As we can see, these are two similar actions. When we write

{% program %}
@my_decorator
{% endprogram %}

<p>we simply tell the interpreter to call a function named <code>my_decorator</code>. That's the important point, because this name can either lead us directly to the decorator ... or not!
Let's do something scary! :)

{% program %}
def decorator_maker():
 
    print "I create decorators! I'll be called only once: "+\
          "when you ask me to create a decorator."
 
    def my_decorator(func):
 
        print "I am decorator! I'll be called only once: while decorating function."
 
        def wrapped():
            print ("I am wrapping around the decorated function."
                  "I will be called each time you call a decorated function."
                  "I will return the result decorated function provides.")
            return func()
 
        print "I return the wrapped function."
 
        return wrapped
 
    print "I return the decorator."
    return my_decorator

# Let's now create a decorator. This is just another function call
new_decorator = decorator_maker()
# prints:
# I create decorators! I'll be called only once when you ask me to create a decorator.
# I return the decorator.
 
# Now we decorate the function:
 
def decorated_function():
    print "I am the function to be decorated."
 
decorated_function = new_decorator(decorated_function)
# prints:
# I am decorator! I'll be called only once: while decorating function.
# I return the wrapped function.
 
# At last call the function:
decorated_function()
# prints:
# I am wrapping around the decorated function. I will be called each time you call a decorated function.
# I will return the result decorated function provides.
# I am the function to be decorated.
{% endprogram %}

<p>Looks too long? You're right. Let's rewrite this code without  using the intermediate variables:

{% program %}
def decorated_function():
    print "I am the function to be decorated."
decorated_function = decorator_maker()(decorated_function)
# prints:
# I create decorators! I'll be called only once when you ask me to create a decorator.
# I return the decorator.
# I am decorator! I'll be called only once: while decorating function.
# I return the wrapped function.
 
# And then:
decorated_function()
# prints:
# I am wrapping around the decorated function. I will be called each time you call a decorated function.
# I will return the result decorated function provides.
# I am the function to be decorated.
{% endprogram %}

<p>We can try again to make it even shorter:

{% program %}
@decorator_maker()
def decorated_function():
    print "I am the decorated function."
# prints:
# I create decorators! I'll be called only once when you ask me to create a decorator.
# I return the decorator.
# I am decorator! I'll be called only once: while decorating function.
# I return the wrapped function.
 
# Aaaaand again:
decorated_function()
# prints:
# I am wrapping around the decorated function. I will be called each time you call a decorated function.
# I will return the result decorated function work.
# I am the function to be decorated.
{% endprogram %}

<p>Have you noticed that we called the function right after the sign "@"?:)

<p>Now finally return  to the decorators arguments, because if we use the function to create decorators quickly,  we can pass it any arguments, right?

{% program %}
def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):
 
    print "I create decorators. And i have received the following arguments:", decorator_arg1, decorator_arg2
 
    def my_decorator(func):
        print "I am decorator. And you have managed to pass me those arguments:", decorator_arg1, decorator_arg2
 
        # Do not confuse decorators' arguments with arguments of functions!
        def wrapped(function_arg1, function_arg2) :
            print ("I wrap around the decorated function.\n"
                  "And I have access to all the arguments: \n"
                  "\t- of the decorator: {0} {1}\n"
                  "\t- of the function: {2} {3}\n"
                  "Now I can pass the necessary arguments on"
                  .format(decorator_arg1, decorator_arg2,
                          function_arg1, function_arg2))
            return func(function_arg1, function_arg2)
 
        return wrapped
 
    return my_decorator

@decorator_maker_with_arguments("Leonard", "Sheldon")
def decorated_function_with_arguments(function_arg1, function_arg2):
    print ("I am the function to be decorated and everything I know are my arguments: {0}"
           " {1}".format(function_arg1, function_arg2))
 
decorated_function_with_arguments("Rajesh", "Howard")
# prints:
# I create decorators! And I received the following arguments: Sheldon Leonard
# I am the decorator. And you are still able to give me these arguments: Sheldon Leonard
# I am the wrapping around the decorated function.
# And I have access to all the arguments:
# - Of decorator: Sheldon Leonard
# - Of functions: Rajesh Howard
# Now I can pass the necessary arguments on
# I am the function to be decorated and I only know about my arguments: Rajesh Howard
{% endprogram %}

<p>Here he is, the desired decorator you can pass arbitrary arguments to.
Of course, the argument can be any variable:

{% program %}
c1 = "Penny"
c2 = "Leslie"
 
@decorator_maker_with_arguments("Leonard", c1)
def decorated_function_with_arguments(function_arg1, function_arg2):
    print ("I am the function to be decorated and I know only about my arguments: {0}"
           " {1}".format(function_arg1, function_arg2))
 
decorated_function_with_arguments(c2, "Howard")
# prints:
# I create decorators! And I received the following arguments: Leonard Penny
# I am the decorator. And you are still able to give me these arguments: Leonard Penny
# I am the wrapping around the decorated function.
# And I have access to all the arguments:
# - Of decorator: Leonard Penny
# - Of functions: Leslie Howard
# Now I can pass the necessary arguments on
# I am the function to be decorated and I only know about my arguments: Leslie Howard
{% endprogram %}

<p>Thus, we can pass any arguments to the decorator just as for an ordinary function. We may use  decompression via <code>*args</code> and <code>**kwargs</code> if necessary.
<p>But you must always keep in mind that the decorator is called <b>only once</b>. Exactly at the time  Python imports your script. After that, we cannot in any way change the arguments he is called with.
When we write a <code>import x</code>, all the functions of the <code>x</code> <b> are decorated immediately</b>, and we can't change anything.

{% endsection %}

{% section "A little practice: writing a decorator decorating decorator" %}


<p>If you've read up to this point, and want to continue here's a bonus from me.
This little trick will allow you to turn any ordinary decorator to decorator taking arguments.
Initially, to get decorator taking arguments, we have created it with an another function.
We wrapped our decorator.
Do we have something then to wrap a function?
Exactly, decorators!

<p>Let's have fun and write a decorator for decorators:

{% program %}
def decorator_with_args(decorator_to_enhance):
    """
    This function is intended as the decorator and for the decorators.
     It should decorate another function which would also be a decorator.
     Better get yourself a cup of coffee.
     It enables any decorator to take arbitrary arguments
     saving you the headache of how this is done, each time when this functionality is needed.
    """
 
    # We use the same trick we used to pass arguments:
    def decorator_maker(*args, **kwargs):
 
        # quickly create a decorator which only takes function 
         # as an argument, but retains all the arguments passed to its "creator"
         def decorator_wrapper (func):
 
             # We return what the original decorator will return to us, which in its turn
             # is JUST A FUNCTION (returning function).
             # The only problem is that the decorator has to be just 
             # decorator (func, *args, **kwargs)
             # this type, otherwise it will not work
            return decorator_to_enhance(func, *args, **kwargs)
 
        return decorator_wrapper
 
    return decorator_maker
{% endprogram %}

<p>This can be used as follows:

{% program %}
# We create a function that we will use as a decorator, and decorate it:-)
# Do not forget that it must be of the form "decorator(func, *args, **kwargs)"
@decorator_with_args
def decorated_decorator(func, *args, **kwargs):
    def wrapper(function_arg1, function_arg2):
        print "I've been given...:", args, kwargs
        return func(function_arg1, function_arg2)
    return wrapper
 
# Now we decorate any function with our new shiny decorator:

@decorated_decorator(42, 404, 1024)
def decorated_function(function_arg1, function_arg2):
    print "Hello", function_arg1, function_arg2
 
decorated_function("Universe and", "everything else")
# prints:
# I've been given....: (42, 404, 1024) {}
# Hello Universe and everything else
 
# Phewww!
{% endprogram %}


<p>I think I know how do you feel right now.
Last time you had this feeling listening to: &quot;In order to understand recursion you need to understand recursion&quot;.
But are  you  happy now, understanding this? ;)


{% endsection %}

{% section "Working with decorators: recommendations" %}

<ul>
<li> Decorators were introduced in Python 2.4, so find out what platform will run your code.</li>
<li> Decorators  slow function call, do not forget about it. </li>
<li> You can't &quot;undecorate &quot; a function. Of course, there are tricks that allow to create a decorator that can be detached from the function, but it is a bad idea. It will be better to remember that if function is decorated  it can't be cancelled. </li>
<li> Decorators wrap functions, which complicates debugging. </li>
</ul>

<p>The latter problem is partially solved in Python 2.5 by adding the standard library module <em>functools</em> includes <em>functools.wraps</em>, that copies all of the information about the wrapped function (her name, her module, its docstrings, etc.) into the wrap-function.
The fun fact is, <em>functools.wraps</em> is the decorator itself.

{% program %}
# While debugging, a function  __name__ is displayed in the trace information.
def foo():
    print "foo"
 
print foo.__name__
# prints: foo
 
# However, decorators affect the process:
def bar(func):
    def wrapper():
        print "bar"
        return func()
    return wrapper
 
@bar
def foo():
    print "foo"
 
print foo.__name__
# prints: wrapper

# "functools" can help us here
 
import functools
 
def bar(func):
    # Declare "wrapper" wrapping "func"
    # and here comes the magic:
    @functools.wraps(func)
    def wrapper():
        print "bar"
        return func()
    return wrapper
 
@bar
def foo():
    print "foo"
 
print foo.__name__
# prints: foo
{% endprogram %}

{% endsection %}


{% section "Why do I need decorators?" %}

<p>In conclusion, I would like to answer the one frequently asked question: why do we need decorators? How can we use them?
Decorators can be used to empower the functions of external libraries (which code we cannot change), or to simplify debugging (we do not want to change the unstable code).
They are also useful for expanding various functions with the same code without rewriting it every time, for example:

{% program %}
def benchmark(func):
    """
    Decorator that displays the execution time  
    of the decorated function.
    """
    import time
    def wrapper(*args, **kwargs):
        t = time.clock()
        res = func(*args, **kwargs)
        print func.__name__, time.clock() - t
        return res
    return wrapper
 
 
def logging(func):
    """
    Decorator logging the code execution.
    (ok, it simply outputs calls, but logging could've been here!)
    """
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        print func.__name__, args, kwargs
        return res
    return wrapper


def counter(func):
    """
    Decorator, reading and printing the number
    of calls of a decorated function.
    """
    def wrapper(*args, **kwargs):
        wrapper.count += 1
        res = func(*args, **kwargs)
        print "{0} has been called: {1}x".format(func.__name__, wrapper.count)
        return res
    wrapper.count = 0
    return wrapper
 
 
@benchmark
@logging
@counter
def reverse_string(string):
    return str(reversed(string))
 
print reverse_string("А роза упала на лапу Азора")
print reverse_string("A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!")

# this will print out as output:
# reverse_string ('А роза упала на лапу Азора',) {}
# wrapper 0.0
# reverse_string was called: 1x
# арозА упал ан алапу азор А
# reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {}
# wrapper 0.0
# reverse_string was called: 2x
# !amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A
{% endprogram %}


<p>Thus, decorators can be applied to any function to extend its functionality without rewriting a single line of code!

{% program %}
import httplib
 
@benchmark
@logging
@counter
def get_random_futurama_quote():
    conn = httplib.HTTPConnection("slashdot.org:80")
    conn.request("HEAD", "/index.html")
    for key, value in conn.getresponse().getheaders():
        if key.startswith("x-b") or key.startswith("x-f"):
            return value
    return "Sorry, I can't!"
 
print get_random_futurama_quote()
print get_random_futurama_quote()
 
#outputs:
#get_random_futurama_quote () {}
#wrapper 0.02
#get_random_futurama_quote was called: 1x
#The laws of science be a harsh mistress.
#get_random_futurama_quote () {}
#wrapper 0.01
#get_random_futurama_quote was called: 2x
#Curse you, merciful Poseidon!
{% endprogram %}


<p>Python includes different decorators  such as  <em>property</em>, <em>staticmethod</em> etc.
In Django, decorators are used to control caching, control access rights and to define  address handlers. In  Twisted they are used  to create fake inline asynchronous calls.

<p>Decorators open the widest room for experiments. Now go solve the problems!



{% endsection %}
